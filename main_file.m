% main_file - the main file to activate the Intel® RealSense™
% 	D435 camera for the use of "Dynamisierte Fertigungsketten". This 
% 	program needs to be used with Intel® RealSense™ SDK 2.0 and its
% 	MATLAB wrapper, which can be downloaded from:
% 	https://github.com/IntelRealSense/librealsense
% 
% The program is inspired by Henrik Wilhelm Becker and his program in
% bachelor thesis for a Microsoft Kinect v2 camera. This version of 
% the program is reprogrammed by Chijiang Duan for Intel® RealSense™
% D435 Camera and its SDK v2.0.
%
%
% Other m-files required: 	next_frame.m
%							foregrndDetection.m
%							crop_ptCloud.m 
%							icp_Classification.m 
%							object_position.m 
%                           findBinMarkers.m
%							create_VideoFrame.m
%							find_p3.m 
%							draw_p3.m 
%							calc_corr_arr.m 

% MAT-files required: 
%     Constants_1.mat  Referenzdatenbank9_2.mat
%     ./test/rs.mat  ./+realsense/  start_process_2018a.slx
%     write_data_2018a.slx
%
% Author: Chijiang Duan
% email: chijiang.duan@tu-braunschweig.de
% May 2019; Version 1.2.1
%------------- BEGIN CODE --------------
clc; clear; close all;
% Load background.
load('test/rs.mat')

% Necessary variables.
load('Constants_1.mat')
load('Referenzdatenbank9_2.mat')
%% Set up the camera parameters.
% Create communication pipeline.
pipe = realsense.pipeline();
% Create configuration object for pipeline.
config = realsense.config();
% Set resolution data for depth and rgb sensor.
config.enable_stream(realsense.stream.depth,...
    1280, 720, realsense.format.z16, 30)
config.enable_stream(realsense.stream.color,...
    1280, 720, realsense.format.rgb8, 30)
% Colorize the depth image. 2 = black to write.
colorizer = realsense.colorizer(2);
% Crop depth image to match the rgb image.
align_to = realsense.stream.color;
alignedFs = realsense.align(align_to);
% Create point cloud calculator.
pointcloud = realsense.pointcloud();

% Create the Blob analysis object for foreground detection.
blobAnalysis = vision.BlobAnalysis('MinimumBlobArea',30000,...
    'MaximumBlobArea',1000000);

% Start camera streaming.
profile = pipe.start(config);
% Set dynamic range parameter for depth sensor.
depth_sensor = profile.get_device().first('depth_sensor');
depth_sensor.set_option(realsense.option.visual_preset, 1); 

%% Object detection and recognition.
% Capture the images untill object recognized.
while 1
    % Get next frame.
    [depth, depth_img, color_img] = next_frame(pipe, colorizer, alignedFs);
    % Calculates point coordinates in point cloud generated by depth image.
    points = pointcloud.calculate(depth);
    vertices = points.get_vertices();
    % Create point cloud object
    ptCloud = pointCloud(vertices);
    % Skip to next frame if error pops.
    try
        % Detect the foreground.
        [img_w_obj,~,~, bbox] = foregrndDetection(...
            depth_img,background,blobAnalysis,color_img);
        if size(bbox, 1) ~= 1
            continue
        end
        % Crop the point cloud of the object out of the entire point cloud.
        ptCloud = crop_ptCloud(ptCloud, bbox);
        % Classify the object.
        [errValue, objectID] = icp_Classification(...
            ptCloud,Referenzdatenbank,Constants);
        % Calculates the welding positions.
        weldingPos = object_position(ptCloud,Referenzdatenbank,objectID); 
        if isempty(weldingPos)
            continue
        end
        % Locate the binary marks.
        centerBright = findBinMarkers(color_img); 
        if size(centerBright,1) == 3
            % Caculate the center location of the workpiece carrier.
            [alpha,center_loc] = global_position(centerBright,...
                color_img,Constants);
        else
            continue
        end
        % Calculate the vectors point to welding points from center.
        welding_vector = weldingPos - center_loc;
        break
    catch
        continue
    end
end
% Safty height for robot operation.
safty_height = (ptCloud.ZLimits(2) - ptCloud.ZLimits(1)) * 1000;
% Calculate the welding positions in robot #BASE corrdinate.
welding_pos_sys = ([0,1,0;1,0,0;0,0,-1] * welding_vector')'...
    * 1000 + [-284, 196.5, 0];
% Reform the array to a 30 element array.
array_length = numel(welding_pos_sys);
welding_pos_sys = reshape(welding_pos_sys', [1,array_length]);
transfer_array = zeros(1,30);
transfer_array(1:array_length) = welding_pos_sys;
transfer_array(array_length+1) = 11111;
% Draw informations on the captured color frame.
imshow(create_VideoFrame(img_w_obj,weldingPos))

%% Velocity measurement
% Video player initialize.
videoplayer = vision.VideoPlayer();
% Last recorded center location.
last_loc = [];
% Recorded velocity.
vel_vec = [];
% Number of recorded velocities.
counter = 1;
% Number of frames with error.
errImg = 0;
% Start time recording.
tic;
while true
    % capture next frame.
    [~, ~, color_img] = next_frame(pipe, colorizer, alignedFs);
    t = toc;
    try
        % Calculating center location.
        p3_loc = find_p3(color_img);
        center_loc = p3_loc + [0.1623, 0.2471, 0];
        
        % Drawing the binary marks.
        circles = draw_p3(color_img);
        circles(:,3) = 8;
        RGB = insertShape(color_img,'circle', circles,...
            'LineWidth', 5, 'Color', 'g');
        
        % Insert center location text.
        RGB = insertText(RGB,[10 10],...
            sprintf('Center Location: \n%s', num2str(center_loc)),...
                'FontSize', 18);
        % Calculating the velocity.
        if ~isempty(last_loc)
            % Calculate the velocity if not the first location recorded.
            velocity = (center_loc - last_loc) / (t - t_last);
            acceleration = (velocity - last_velocity) / (t - t_last);
            % Assign current loction to the last.
            last_loc = center_loc;
            last_velocity = velocity;
            % Assign current time to the last
            t_last = t;
            % Insert the velocity text.
            RGB = insertText(RGB,[10 70],...
                sprintf('Velocity: \n%s', num2str(velocity)),...
                    'FontSize', 18);
            % Add calculated velocity to the list.
            vel_vec(counter, :) = velocity;
            acc_vec(counter, :) = acceleration;
            counter = counter + 1;
            % Break the loop when velocity constant.
            if (norm(acceleration) < 0.12) && (norm(velocity) > 0.1)
                no_acc = no_acc + 1;
                if no_acc > 2
                    break
                end
            else
                no_acc = 0;
            end
        else
            % Assign the very first location and time point.
            last_loc = center_loc;
            t_last = t;
            start_loc = center_loc;
            last_velocity = 0;
        end
        errImg = 0;
    catch
        % Tell the failure of finding biary marks.
        RGB = insertText(color_img,[10 10],'Binary code not detected',...
            'FontSize', 18);
        errImg = errImg + 1;
        if errImg > 2
            break
        end
    end
    videoplayer(RGB)
end
tic; % Ending time of capture.
% Calculate the average velocity.
vel_norm = [];
for i = 1:size(vel_vec, 1)
    vel_norm(i) = norm(vel_vec(i,:));
end
v_m = mean(vel_norm(end-3:end)) * 1000;
trigger = false;
% Send the velocity.
sim('start_process_2018a')
% ANN correction.
transfer_array = calc_corr_arr(transfer_array, v_m);
% Write data to TwinCAT.
sim('write_data_2018a')

% Calculate the length the workpiece need to run.
run_length = 0.5135 - norm(last_loc - start_loc);
robot_acc = 4.6; % Robot acceleration.
% Wait for the trigger time.
pause(run_length/v_m - toc - v_m/2/robot_acc - 0.001)

% Start TwinCAT program.
trigger = true;
sim('start_process_2018a')

% Draw the diagrams
figure
plot(vel_norm)
line([0, ceil(i/10)*10], [v_m, v_m], 'Color', 'red')
title('Velocity for each frame')
xlabel('frame number')
ylabel('velocity [m/s]')
grid minor
grid on
legend('velocity')

acc_norm = [];
for i = 1:size(vel_vec, 1)
    acc_norm(i) = norm(acc_vec(i,:));
end
figure
plot(acc_norm, 'r')
title('Acceleration for each frame')
xlabel('frame number')
ylabel('acceleration [m/s^2]')
grid minor
grid on
legend('Acceleration')

% Destroy the pipeline object.
pipe.stop()
%------------- END OF CODE --------------